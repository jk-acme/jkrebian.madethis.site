// source/worker.js
import module from "node:module";
import { parentPort, workerData } from "node:worker_threads";

// source/constants.js
var WORKER_FILE_NAME = "worker.mjs";
var WORKER_ACTION_APPLY = "[[WORKER_ACTION_APPLY]]";
var WORKER_ACTION_GET = "[[WORKER_ACTION_GET]]";
var WORKER_ACTION_OWN_KEYS = "[[WORKER_ACTION_OWN_KEYS]]";
var WORKER_ACTION_GET_INFORMATION = "[[WORKER_ACTION_GET_INFORMATION]]";
var VALUE_TYPE_FUNCTION = "[[VALUE_TYPE_FUNCTION]]";
var VALUE_TYPE_PRIMITIVE = "[[VALUE_TYPE_PRIMITIVE]]";
var VALUE_TYPE_PLAIN_OBJECT = "[[VALUE_TYPE_PLAIN_OBJECT]]";
var VALUE_TYPE_UNKNOWN = "[[VALUE_TYPE_UNKNOWN]]";
var VALUE_INFORMATION_FUNCTION = { type: VALUE_TYPE_FUNCTION };
var WORKER_FILE = new URL(WORKER_FILE_NAME, import.meta.url);
var STDIO_STREAMS = ["stdout", "stderr"];

// source/get-value-information.js
var PRIMITIVE_VALUE_TYPES = /* @__PURE__ */ new Set([
  "undefined",
  "boolean",
  "number",
  "bigint",
  "string"
]);
var isPrimitive = (value) => value === null || PRIMITIVE_VALUE_TYPES.has(typeof value);
function getPlainObjectPropertyInformation(object, key) {
  const descriptor = Object.getOwnPropertyDescriptor(object, key);
  if (!Object.hasOwn(descriptor, "value")) {
    return;
  }
  const { value } = descriptor;
  if (isPrimitive(value)) {
    return { type: VALUE_TYPE_PRIMITIVE, value };
  }
}
function getValueInformation(value) {
  if (typeof value === "function") {
    return VALUE_INFORMATION_FUNCTION;
  }
  if (isPrimitive(value)) {
    return { type: VALUE_TYPE_PRIMITIVE, value };
  }
  const information = { type: VALUE_TYPE_UNKNOWN };
  if (Object.getPrototypeOf(value) === null) {
    information.type = VALUE_TYPE_PLAIN_OBJECT;
    information.isNullPrototypeObject = true;
  }
  if (value.constructor === Object) {
    information.type = VALUE_TYPE_PLAIN_OBJECT;
  }
  if (information.type === VALUE_TYPE_PLAIN_OBJECT) {
    information.properties = new Map(
      Object.keys(value).map((property) => [
        property,
        getPlainObjectPropertyInformation(value, property)
      ])
    );
  }
  return information;
}
var get_value_information_default = getValueInformation;

// source/lock.js
var STATE_UNLOCKED = 2;
var SIGNAL_INDEX = 0;
var unlock = (semaphore) => {
  Atomics.store(semaphore, SIGNAL_INDEX, STATE_UNLOCKED);
  Atomics.notify(semaphore, SIGNAL_INDEX, 1);
};

// source/property-path.js
var normalizePath = (propertyOrPath = []) => Array.isArray(propertyOrPath) ? propertyOrPath : [propertyOrPath];

// source/responsor.js
import process from "node:process";
import util from "node:util";
var originalProcessExit = process.exit;
var Responsor = class {
  #channel;
  #actionHandlers;
  #stdio = [];
  #responseSemaphore;
  constructor(actionHandlers2, channel) {
    this.#actionHandlers = actionHandlers2;
    this.#channel = channel;
    process.exit = (exitCode) => {
      process.exitCode = exitCode;
      this.#terminate();
      originalProcessExit(exitCode);
    };
    for (const stream of STDIO_STREAMS) {
      process[stream]._writev = (chunks, callback) => {
        for (const { chunk } of chunks) {
          this.#stdio.push({ stream, chunk });
        }
        callback();
      };
    }
  }
  #send(response) {
    const { responsePort } = this.#channel;
    const stdio = this.#stdio;
    const exitCode = process.exitCode ?? 0;
    try {
      responsePort.postMessage({ ...response, stdio, exitCode });
    } catch {
      const error = new Error(
        `Cannot serialize worker response:
${util.inspect(response.result)}`
      );
      responsePort.postMessage({ error, stdio, exitCode });
    } finally {
      this.#finish();
    }
  }
  #sendResult(result) {
    this.#send({ result });
  }
  #throws(error) {
    this.#send({ error, errorData: { ...error } });
  }
  #finish() {
    unlock(this.#responseSemaphore);
    process.exitCode = void 0;
    this.#responseSemaphore = void 0;
    this.#stdio.length = 0;
  }
  #terminate() {
    this.#send({ terminated: true });
  }
  #processAction(action, payload) {
    const actionHandlers2 = this.#actionHandlers;
    if (!actionHandlers2.has(action)) {
      throw new Error(`Unknown action '${action}'.`);
    }
    return actionHandlers2.get(action)(payload);
  }
  async process({ responseSemaphore, action, payload }) {
    this.#responseSemaphore = responseSemaphore;
    try {
      this.#sendResult(await this.#processAction(action, payload));
    } catch (error) {
      this.#throws(error);
    }
  }
  destroy() {
    this.#channel.responsePort.close();
    process.exitCode = void 0;
  }
};
var responsor_default = Responsor;

// source/worker.js
module.enableCompileCache?.();
var createHandler = (handler) => async (payload) => handler(await getValue(payload), payload);
var actionHandlers = new Map(
  [
    [WORKER_ACTION_GET, ({ value }) => value],
    [
      WORKER_ACTION_APPLY,
      ({ value: method, receiver }, { argumentsList }) => Reflect.apply(method, receiver, argumentsList)
    ],
    [
      WORKER_ACTION_OWN_KEYS,
      ({ value }) => Reflect.ownKeys(value).filter((key) => typeof key !== "symbol")
    ],
    [WORKER_ACTION_GET_INFORMATION, ({ value }) => get_value_information_default(value)]
  ].map(([action, handler]) => [action, createHandler(handler)])
);
var responsor;
parentPort.addListener(
  "message",
  ({ channel, responseSemaphore, action, payload }) => {
    if (channel) {
      responsor?.destroy();
      responsor = new responsor_default(actionHandlers, channel);
    }
    responsor.process({ responseSemaphore, action, payload });
  }
);
var { workerRunningSemaphore } = workerData;
if (workerRunningSemaphore) {
  unlock(workerRunningSemaphore);
}
var moduleInstance;
var moduleLoadError;
var moduleImportPromise = loadModule();
async function getValue(payload) {
  if (moduleLoadError) {
    throw moduleLoadError;
  }
  moduleInstance ??= await moduleImportPromise;
  let value = moduleInstance;
  let receiver;
  for (const property of normalizePath(payload.path)) {
    receiver = value;
    value = Reflect.get(value, property, value);
  }
  return { value, receiver };
}
async function loadModule() {
  try {
    return await import(workerData.moduleId);
  } catch (error) {
    moduleLoadError = error;
  }
}
