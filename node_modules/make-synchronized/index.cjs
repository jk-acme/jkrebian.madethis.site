"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// source/index.js
var index_exports = {};
__export(index_exports, {
  default: () => index_default,
  makeDefaultExportSynchronized: () => makeDefaultExportSynchronized,
  makeModuleSynchronized: () => makeModuleSynchronized,
  makeSynchronized: () => makeSynchronized,
  makeSynchronizedFunction: () => makeSynchronizedFunction,
  makeSynchronizedFunctions: () => makeSynchronizedFunctions
});
module.exports = __toCommonJS(index_exports);
var import_node_module = __toESM(require("node:module"), 1);
var import_node_worker_threads3 = require("node:worker_threads");

// source/constants.js
var path = __toESM(require("node:path"), 1);
var WORKER_FILE_NAME = "worker.mjs";
var WORKER_ACTION_APPLY = "[[WORKER_ACTION_APPLY]]";
var WORKER_ACTION_GET = "[[WORKER_ACTION_GET]]";
var WORKER_ACTION_OWN_KEYS = "[[WORKER_ACTION_OWN_KEYS]]";
var WORKER_ACTION_GET_INFORMATION = "[[WORKER_ACTION_GET_INFORMATION]]";
var VALUE_TYPE_FUNCTION = "[[VALUE_TYPE_FUNCTION]]";
var VALUE_TYPE_PRIMITIVE = "[[VALUE_TYPE_PRIMITIVE]]";
var VALUE_TYPE_PLAIN_OBJECT = "[[VALUE_TYPE_PLAIN_OBJECT]]";
var VALUE_TYPE_UNKNOWN = "[[VALUE_TYPE_UNKNOWN]]";
var VALUE_INFORMATION_FUNCTION = { type: VALUE_TYPE_FUNCTION };
var WORKER_FILE = path.join(__dirname, WORKER_FILE_NAME);
var IS_PRODUCTION = true;
var ATOMICS_WAIT_RESULT_TIMED_OUT = "timed-out";

// source/get-value-information.js
var PRIMITIVE_VALUE_TYPES = /* @__PURE__ */ new Set([
  "undefined",
  "boolean",
  "number",
  "bigint",
  "string"
]);
var isPrimitive = (value) => value === null || PRIMITIVE_VALUE_TYPES.has(typeof value);
function getPlainObjectPropertyInformation(object, key) {
  const descriptor = Object.getOwnPropertyDescriptor(object, key);
  if (!Object.hasOwn(descriptor, "value")) {
    return;
  }
  const { value } = descriptor;
  if (isPrimitive(value)) {
    return { type: VALUE_TYPE_PRIMITIVE, value };
  }
}
function getValueInformation(value) {
  if (typeof value === "function") {
    return VALUE_INFORMATION_FUNCTION;
  }
  if (isPrimitive(value)) {
    return { type: VALUE_TYPE_PRIMITIVE, value };
  }
  const information = { type: VALUE_TYPE_UNKNOWN };
  if (Object.getPrototypeOf(value) === null) {
    information.type = VALUE_TYPE_PLAIN_OBJECT;
    information.isNullPrototypeObject = true;
  }
  if (value.constructor === Object) {
    information.type = VALUE_TYPE_PLAIN_OBJECT;
  }
  if (information.type === VALUE_TYPE_PLAIN_OBJECT) {
    information.properties = new Map(
      Object.keys(value).map((property) => [
        property,
        getPlainObjectPropertyInformation(value, property)
      ])
    );
  }
  return information;
}
var get_value_information_default = getValueInformation;

// source/property-path.js
var normalizePath = (propertyOrPath = []) => Array.isArray(propertyOrPath) ? propertyOrPath : [propertyOrPath];
var hashPath = (path3) => JSON.stringify(normalizePath(path3));

// source/threads-worker.js
var import_node_process = __toESM(require("node:process"), 1);
var util = __toESM(require("node:util"), 1);
var import_node_worker_threads2 = require("node:worker_threads");

// source/atomics-wait-error.js
var AtomicsWaitError = class extends Error {
  code = "";
  name = "AtomicsWaitError";
  constructor(code) {
    super(
      code === ATOMICS_WAIT_RESULT_TIMED_OUT ? "Timed out" : "Unexpected error"
    );
    this.code = code;
  }
};
var atomics_wait_error_default = AtomicsWaitError;

// source/channel.js
var import_node_worker_threads = require("node:worker_threads");
var Channel = class {
  mainThreadPort;
  workerPort;
  alive = true;
  constructor() {
    const { port1: mainThreadPort, port2: workerPort } = new import_node_worker_threads.MessageChannel();
    mainThreadPort.unref();
    workerPort.unref();
    this.mainThreadPort = mainThreadPort;
    this.workerPort = workerPort;
  }
  getResponse(lock) {
    try {
      lock.lock();
    } catch (error) {
      if (error instanceof atomics_wait_error_default) {
        this.destroy();
      }
      throw error;
    }
    return this.#receiveMessage();
  }
  #receiveMessage() {
    const port = this.mainThreadPort;
    let lastEntry;
    while (true) {
      const entry = (0, import_node_worker_threads.receiveMessageOnPort)(port);
      if (!entry) {
        return lastEntry.message;
      }
      lastEntry = entry;
    }
  }
  destroy() {
    if (!this.alive) {
      return;
    }
    this.alive = false;
    this.mainThreadPort.close();
    this.workerPort.close();
    this.mainThreadPort = void 0;
    this.workerPort = void 0;
  }
};
var channel_default = Channel;

// source/lock.js
var SIGNAL_INDEX = 0;
var Lock = class {
  semaphore = new Int32Array(
    new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT)
  );
  lock(timeout) {
    const { semaphore } = this;
    this.semaphore = void 0;
    if (Atomics.load(semaphore, SIGNAL_INDEX) > 0) {
      return;
    }
    const result = Atomics.wait(semaphore, SIGNAL_INDEX, 0, timeout);
    if (result !== ATOMICS_WAIT_RESULT_TIMED_OUT) {
      return;
    }
    throw new atomics_wait_error_default(result);
  }
};
var lock_default = Lock;

// source/threads-worker.js
var ThreadsWorker = class {
  #worker;
  #workerData;
  #channel;
  constructor(workerData) {
    this.#workerData = workerData;
  }
  #createWorker() {
    const lock = IS_PRODUCTION ? {} : new lock_default();
    const worker = new import_node_worker_threads2.Worker(WORKER_FILE, {
      workerData: {
        workerRunningSemaphore: lock.semaphore,
        ...this.#workerData
      },
      // https://nodejs.org/api/worker_threads.html#new-workerfilename-options
      // Do not pipe `stdio`s
      stdout: true,
      stderr: true
    });
    worker.unref();
    if (IS_PRODUCTION) {
      return worker;
    }
    try {
      lock.lock(1e3);
    } catch (error) {
      if (error instanceof atomics_wait_error_default) {
        throw new Error(
          `Unexpected error, most likely caused by syntax error in '${WORKER_FILE}'`,
          { cause: error }
        );
      }
      throw error;
    }
    return worker;
  }
  #createChannel() {
    if (this.#channel?.alive) {
      return false;
    }
    this.#channel = new channel_default();
    return true;
  }
  sendAction(action, payload) {
    this.#worker ??= this.#createWorker();
    const lock = new lock_default();
    const message = {
      action,
      payload,
      responseSemaphore: lock.semaphore
    };
    const transferList = [];
    const worker = this.#worker;
    let channel = this.#channel;
    if (this.#createChannel()) {
      channel = this.#channel;
      message.channel = {
        responsePort: channel.workerPort
      };
      transferList.push(channel.workerPort);
    }
    try {
      worker.postMessage(message, transferList);
    } catch {
      throw Object.assign(
        new Error(`Cannot serialize request data:
${util.inspect(payload)}`),
        { requestData: payload }
      );
    }
    const { stdio, result, error, errorData, terminated, exitCode } = channel.getResponse(lock);
    for (const { stream, chunk } of stdio) {
      import_node_process.default[stream].write(chunk);
    }
    if (terminated || exitCode !== 0) {
      worker.terminate();
      if (this.#worker === worker) {
        this.#worker = void 0;
      }
      channel.destroy();
    }
    if (error) {
      throw Object.assign(error, errorData);
    }
    return result;
  }
};
var threads_worker_default = ThreadsWorker;

// source/to-module-id.js
var path2 = __toESM(require("node:path"), 1);
var url = __toESM(require("node:url"), 1);
function toModuleId(module3) {
  if (module3 instanceof URL) {
    return module3.href;
  }
  if (typeof module3 === "string" && path2.isAbsolute(module3)) {
    return url.pathToFileURL(module3).href;
  }
  if (typeof module3.url === "string") {
    return module3.url;
  }
  return module3;
}
var to_module_id_default = toModuleId;

// source/synchronizer.js
var cacheResult = (cache, cacheKey, getResult) => {
  if (!cache.has(cacheKey)) {
    cache.set(cacheKey, getResult());
  }
  return cache.get(cacheKey);
};
var cachePathResult = (cache, path3, getResult) => cacheResult(cache, hashPath(path3), getResult);
var Synchronizer = class _Synchronizer {
  static #instances = /* @__PURE__ */ new Map();
  static create({ module: module3 }) {
    const moduleId = to_module_id_default(module3);
    return cacheResult(
      this.#instances,
      moduleId,
      () => new _Synchronizer(moduleId)
    );
  }
  #worker;
  #synchronizedFunctionStore = /* @__PURE__ */ new Map();
  #informationStore = /* @__PURE__ */ new Map();
  #ownKeysStore = /* @__PURE__ */ new Map();
  #plainObjectStore = /* @__PURE__ */ new Map();
  constructor(moduleId) {
    this.#worker = new threads_worker_default({ moduleId });
  }
  getInformation(path3) {
    return cachePathResult(
      this.#informationStore,
      path3,
      () => this.#worker.sendAction(WORKER_ACTION_GET_INFORMATION, { path: path3 })
    );
  }
  setKnownInformation(path3, information) {
    this.#informationStore.set(hashPath(path3), information);
  }
  get(path3) {
    const information = this.getInformation(path3);
    switch (information.type) {
      case VALUE_TYPE_FUNCTION:
        return this.#createSynchronizedFunction(path3);
      case VALUE_TYPE_PRIMITIVE:
        return information.value;
      case VALUE_TYPE_PLAIN_OBJECT:
        return this.#createPlainObjectProxy(path3, information);
      default:
        return this.#worker.sendAction(WORKER_ACTION_GET, { path: path3 });
    }
  }
  ownKeys(path3) {
    return cachePathResult(
      this.#ownKeysStore,
      path3,
      () => this.#worker.sendAction(WORKER_ACTION_OWN_KEYS, { path: path3 })
    );
  }
  apply(path3, argumentsList) {
    return this.#worker.sendAction(WORKER_ACTION_APPLY, { path: path3, argumentsList });
  }
  #createSynchronizedFunction(path3) {
    return cachePathResult(
      this.#synchronizedFunctionStore,
      path3,
      () => (...argumentsList) => this.apply(path3, argumentsList)
    );
  }
  createDefaultExportFunctionProxy() {
    const defaultExportFunction = this.get("default");
    return new Proxy(defaultExportFunction, {
      get: (target, property) => this.get(property)
    });
  }
  #createPlainObjectProxy(path3, { isNullPrototypeObject, properties }) {
    path3 = normalizePath(path3);
    return cachePathResult(this.#plainObjectStore, path3, () => {
      const object = isNullPrototypeObject ? /* @__PURE__ */ Object.create(null) : {};
      for (const [property, propertyInformation] of properties) {
        if (propertyInformation?.type === VALUE_TYPE_PRIMITIVE) {
          object[property] = propertyInformation.value;
        } else {
          Object.defineProperty(object, property, {
            get: () => this.get([...path3, property]),
            enumerable: true,
            configurable: true
          });
        }
      }
      return new Proxy(object, {
        get: (target, property, receiver) => {
          if (typeof property === "symbol" || properties.has(property)) {
            return Reflect.get(target, property, receiver);
          }
          return this.get([...path3, property]);
        }
      });
    });
  }
  createModule() {
    const module3 = Object.create(null, {
      [Symbol.toStringTag]: { value: "Module", enumerable: false }
    });
    const specifiers = this.ownKeys();
    return Object.defineProperties(
      module3,
      Object.fromEntries(
        specifiers.map((specifier) => [
          specifier,
          {
            get: () => this.get(specifier),
            enumerable: true
          }
        ])
      )
    );
  }
};
var synchronizer_default = Synchronizer;

// source/index.js
import_node_module.default.enableCompileCache?.();
function makeSynchronizedFunctions(module3, implementation) {
  if (!import_node_worker_threads3.isMainThread) {
    return implementation;
  }
  const synchronizer = synchronizer_default.create({ module: module3 });
  synchronizer.setKnownInformation(
    void 0,
    get_value_information_default(implementation)
  );
  return new Proxy(implementation, {
    get: (target, property) => typeof implementation[property] === "function" ? synchronizer.get(property) : target[property]
  });
}
function makeSynchronizedFunction(module3, implementation, specifier = "default") {
  if (!import_node_worker_threads3.isMainThread) {
    return implementation;
  }
  const synchronizer = synchronizer_default.create({ module: module3 });
  synchronizer.setKnownInformation(
    specifier,
    get_value_information_default(implementation)
  );
  return synchronizer.get(specifier);
}
function makeDefaultExportSynchronized(module3) {
  return synchronizer_default.create({ module: module3 }).get("default");
}
function makeModuleSynchronized(module3) {
  return synchronizer_default.create({ module: module3 }).createModule();
}
function makeSynchronized(module3, implementation) {
  if (typeof implementation === "function") {
    return makeSynchronizedFunction(module3, implementation);
  }
  if (implementation) {
    return makeSynchronizedFunctions(module3, implementation);
  }
  const synchronizer = synchronizer_default.create({ module: module3 });
  const defaultExportType = synchronizer.getInformation("default").type;
  if (defaultExportType === VALUE_TYPE_FUNCTION) {
    return synchronizer.createDefaultExportFunctionProxy();
  }
  return synchronizer.createModule();
}
var index_default = makeSynchronized;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  makeDefaultExportSynchronized,
  makeModuleSynchronized,
  makeSynchronized,
  makeSynchronizedFunction,
  makeSynchronizedFunctions
});
