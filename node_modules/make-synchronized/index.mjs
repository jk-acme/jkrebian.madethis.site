// source/index.js
import module from "node:module";
import { isMainThread } from "node:worker_threads";

// source/constants.js
var WORKER_FILE_NAME = "worker.mjs";
var WORKER_ACTION_APPLY = "[[WORKER_ACTION_APPLY]]";
var WORKER_ACTION_GET = "[[WORKER_ACTION_GET]]";
var WORKER_ACTION_OWN_KEYS = "[[WORKER_ACTION_OWN_KEYS]]";
var WORKER_ACTION_GET_INFORMATION = "[[WORKER_ACTION_GET_INFORMATION]]";
var VALUE_TYPE_FUNCTION = "[[VALUE_TYPE_FUNCTION]]";
var VALUE_TYPE_PRIMITIVE = "[[VALUE_TYPE_PRIMITIVE]]";
var VALUE_TYPE_PLAIN_OBJECT = "[[VALUE_TYPE_PLAIN_OBJECT]]";
var VALUE_TYPE_UNKNOWN = "[[VALUE_TYPE_UNKNOWN]]";
var VALUE_INFORMATION_FUNCTION = { type: VALUE_TYPE_FUNCTION };
var WORKER_FILE = new URL(WORKER_FILE_NAME, import.meta.url);
var IS_PRODUCTION = true;
var ATOMICS_WAIT_RESULT_TIMED_OUT = "timed-out";

// source/get-value-information.js
var PRIMITIVE_VALUE_TYPES = /* @__PURE__ */ new Set([
  "undefined",
  "boolean",
  "number",
  "bigint",
  "string"
]);
var isPrimitive = (value) => value === null || PRIMITIVE_VALUE_TYPES.has(typeof value);
function getPlainObjectPropertyInformation(object, key) {
  const descriptor = Object.getOwnPropertyDescriptor(object, key);
  if (!Object.hasOwn(descriptor, "value")) {
    return;
  }
  const { value } = descriptor;
  if (isPrimitive(value)) {
    return { type: VALUE_TYPE_PRIMITIVE, value };
  }
}
function getValueInformation(value) {
  if (typeof value === "function") {
    return VALUE_INFORMATION_FUNCTION;
  }
  if (isPrimitive(value)) {
    return { type: VALUE_TYPE_PRIMITIVE, value };
  }
  const information = { type: VALUE_TYPE_UNKNOWN };
  if (Object.getPrototypeOf(value) === null) {
    information.type = VALUE_TYPE_PLAIN_OBJECT;
    information.isNullPrototypeObject = true;
  }
  if (value.constructor === Object) {
    information.type = VALUE_TYPE_PLAIN_OBJECT;
  }
  if (information.type === VALUE_TYPE_PLAIN_OBJECT) {
    information.properties = new Map(
      Object.keys(value).map((property) => [
        property,
        getPlainObjectPropertyInformation(value, property)
      ])
    );
  }
  return information;
}
var get_value_information_default = getValueInformation;

// source/property-path.js
var normalizePath = (propertyOrPath = []) => Array.isArray(propertyOrPath) ? propertyOrPath : [propertyOrPath];
var hashPath = (path2) => JSON.stringify(normalizePath(path2));

// source/threads-worker.js
import process from "node:process";
import * as util from "node:util";
import { Worker } from "node:worker_threads";

// source/atomics-wait-error.js
var AtomicsWaitError = class extends Error {
  code = "";
  name = "AtomicsWaitError";
  constructor(code) {
    super(
      code === ATOMICS_WAIT_RESULT_TIMED_OUT ? "Timed out" : "Unexpected error"
    );
    this.code = code;
  }
};
var atomics_wait_error_default = AtomicsWaitError;

// source/channel.js
import { MessageChannel, receiveMessageOnPort } from "node:worker_threads";
var Channel = class {
  mainThreadPort;
  workerPort;
  alive = true;
  constructor() {
    const { port1: mainThreadPort, port2: workerPort } = new MessageChannel();
    mainThreadPort.unref();
    workerPort.unref();
    this.mainThreadPort = mainThreadPort;
    this.workerPort = workerPort;
  }
  getResponse(lock) {
    try {
      lock.lock();
    } catch (error) {
      if (error instanceof atomics_wait_error_default) {
        this.destroy();
      }
      throw error;
    }
    return this.#receiveMessage();
  }
  #receiveMessage() {
    const port = this.mainThreadPort;
    let lastEntry;
    while (true) {
      const entry = receiveMessageOnPort(port);
      if (!entry) {
        return lastEntry.message;
      }
      lastEntry = entry;
    }
  }
  destroy() {
    if (!this.alive) {
      return;
    }
    this.alive = false;
    this.mainThreadPort.close();
    this.workerPort.close();
    this.mainThreadPort = void 0;
    this.workerPort = void 0;
  }
};
var channel_default = Channel;

// source/lock.js
var SIGNAL_INDEX = 0;
var Lock = class {
  semaphore = new Int32Array(
    new SharedArrayBuffer(Int32Array.BYTES_PER_ELEMENT)
  );
  lock(timeout) {
    const { semaphore } = this;
    this.semaphore = void 0;
    if (Atomics.load(semaphore, SIGNAL_INDEX) > 0) {
      return;
    }
    const result = Atomics.wait(semaphore, SIGNAL_INDEX, 0, timeout);
    if (result !== ATOMICS_WAIT_RESULT_TIMED_OUT) {
      return;
    }
    throw new atomics_wait_error_default(result);
  }
};
var lock_default = Lock;

// source/threads-worker.js
var ThreadsWorker = class {
  #worker;
  #workerData;
  #channel;
  constructor(workerData) {
    this.#workerData = workerData;
  }
  #createWorker() {
    const lock = IS_PRODUCTION ? {} : new lock_default();
    const worker = new Worker(WORKER_FILE, {
      workerData: {
        workerRunningSemaphore: lock.semaphore,
        ...this.#workerData
      },
      // https://nodejs.org/api/worker_threads.html#new-workerfilename-options
      // Do not pipe `stdio`s
      stdout: true,
      stderr: true
    });
    worker.unref();
    if (IS_PRODUCTION) {
      return worker;
    }
    try {
      lock.lock(1e3);
    } catch (error) {
      if (error instanceof atomics_wait_error_default) {
        throw new Error(
          `Unexpected error, most likely caused by syntax error in '${WORKER_FILE}'`,
          { cause: error }
        );
      }
      throw error;
    }
    return worker;
  }
  #createChannel() {
    if (this.#channel?.alive) {
      return false;
    }
    this.#channel = new channel_default();
    return true;
  }
  sendAction(action, payload) {
    this.#worker ??= this.#createWorker();
    const lock = new lock_default();
    const message = {
      action,
      payload,
      responseSemaphore: lock.semaphore
    };
    const transferList = [];
    const worker = this.#worker;
    let channel = this.#channel;
    if (this.#createChannel()) {
      channel = this.#channel;
      message.channel = {
        responsePort: channel.workerPort
      };
      transferList.push(channel.workerPort);
    }
    try {
      worker.postMessage(message, transferList);
    } catch {
      throw Object.assign(
        new Error(`Cannot serialize request data:
${util.inspect(payload)}`),
        { requestData: payload }
      );
    }
    const { stdio, result, error, errorData, terminated, exitCode } = channel.getResponse(lock);
    for (const { stream, chunk } of stdio) {
      process[stream].write(chunk);
    }
    if (terminated || exitCode !== 0) {
      worker.terminate();
      if (this.#worker === worker) {
        this.#worker = void 0;
      }
      channel.destroy();
    }
    if (error) {
      throw Object.assign(error, errorData);
    }
    return result;
  }
};
var threads_worker_default = ThreadsWorker;

// source/to-module-id.js
import * as path from "node:path";
import * as url from "node:url";
function toModuleId(module2) {
  if (module2 instanceof URL) {
    return module2.href;
  }
  if (typeof module2 === "string" && path.isAbsolute(module2)) {
    return url.pathToFileURL(module2).href;
  }
  if (typeof module2.url === "string") {
    return module2.url;
  }
  return module2;
}
var to_module_id_default = toModuleId;

// source/synchronizer.js
var cacheResult = (cache, cacheKey, getResult) => {
  if (!cache.has(cacheKey)) {
    cache.set(cacheKey, getResult());
  }
  return cache.get(cacheKey);
};
var cachePathResult = (cache, path2, getResult) => cacheResult(cache, hashPath(path2), getResult);
var Synchronizer = class _Synchronizer {
  static #instances = /* @__PURE__ */ new Map();
  static create({ module: module2 }) {
    const moduleId = to_module_id_default(module2);
    return cacheResult(
      this.#instances,
      moduleId,
      () => new _Synchronizer(moduleId)
    );
  }
  #worker;
  #synchronizedFunctionStore = /* @__PURE__ */ new Map();
  #informationStore = /* @__PURE__ */ new Map();
  #ownKeysStore = /* @__PURE__ */ new Map();
  #plainObjectStore = /* @__PURE__ */ new Map();
  constructor(moduleId) {
    this.#worker = new threads_worker_default({ moduleId });
  }
  getInformation(path2) {
    return cachePathResult(
      this.#informationStore,
      path2,
      () => this.#worker.sendAction(WORKER_ACTION_GET_INFORMATION, { path: path2 })
    );
  }
  setKnownInformation(path2, information) {
    this.#informationStore.set(hashPath(path2), information);
  }
  get(path2) {
    const information = this.getInformation(path2);
    switch (information.type) {
      case VALUE_TYPE_FUNCTION:
        return this.#createSynchronizedFunction(path2);
      case VALUE_TYPE_PRIMITIVE:
        return information.value;
      case VALUE_TYPE_PLAIN_OBJECT:
        return this.#createPlainObjectProxy(path2, information);
      default:
        return this.#worker.sendAction(WORKER_ACTION_GET, { path: path2 });
    }
  }
  ownKeys(path2) {
    return cachePathResult(
      this.#ownKeysStore,
      path2,
      () => this.#worker.sendAction(WORKER_ACTION_OWN_KEYS, { path: path2 })
    );
  }
  apply(path2, argumentsList) {
    return this.#worker.sendAction(WORKER_ACTION_APPLY, { path: path2, argumentsList });
  }
  #createSynchronizedFunction(path2) {
    return cachePathResult(
      this.#synchronizedFunctionStore,
      path2,
      () => (...argumentsList) => this.apply(path2, argumentsList)
    );
  }
  createDefaultExportFunctionProxy() {
    const defaultExportFunction = this.get("default");
    return new Proxy(defaultExportFunction, {
      get: (target, property) => this.get(property)
    });
  }
  #createPlainObjectProxy(path2, { isNullPrototypeObject, properties }) {
    path2 = normalizePath(path2);
    return cachePathResult(this.#plainObjectStore, path2, () => {
      const object = isNullPrototypeObject ? /* @__PURE__ */ Object.create(null) : {};
      for (const [property, propertyInformation] of properties) {
        if (propertyInformation?.type === VALUE_TYPE_PRIMITIVE) {
          object[property] = propertyInformation.value;
        } else {
          Object.defineProperty(object, property, {
            get: () => this.get([...path2, property]),
            enumerable: true,
            configurable: true
          });
        }
      }
      return new Proxy(object, {
        get: (target, property, receiver) => {
          if (typeof property === "symbol" || properties.has(property)) {
            return Reflect.get(target, property, receiver);
          }
          return this.get([...path2, property]);
        }
      });
    });
  }
  createModule() {
    const module2 = Object.create(null, {
      [Symbol.toStringTag]: { value: "Module", enumerable: false }
    });
    const specifiers = this.ownKeys();
    return Object.defineProperties(
      module2,
      Object.fromEntries(
        specifiers.map((specifier) => [
          specifier,
          {
            get: () => this.get(specifier),
            enumerable: true
          }
        ])
      )
    );
  }
};
var synchronizer_default = Synchronizer;

// source/index.js
module.enableCompileCache?.();
function makeSynchronizedFunctions(module2, implementation) {
  if (!isMainThread) {
    return implementation;
  }
  const synchronizer = synchronizer_default.create({ module: module2 });
  synchronizer.setKnownInformation(
    void 0,
    get_value_information_default(implementation)
  );
  return new Proxy(implementation, {
    get: (target, property) => typeof implementation[property] === "function" ? synchronizer.get(property) : target[property]
  });
}
function makeSynchronizedFunction(module2, implementation, specifier = "default") {
  if (!isMainThread) {
    return implementation;
  }
  const synchronizer = synchronizer_default.create({ module: module2 });
  synchronizer.setKnownInformation(
    specifier,
    get_value_information_default(implementation)
  );
  return synchronizer.get(specifier);
}
function makeDefaultExportSynchronized(module2) {
  return synchronizer_default.create({ module: module2 }).get("default");
}
function makeModuleSynchronized(module2) {
  return synchronizer_default.create({ module: module2 }).createModule();
}
function makeSynchronized(module2, implementation) {
  if (typeof implementation === "function") {
    return makeSynchronizedFunction(module2, implementation);
  }
  if (implementation) {
    return makeSynchronizedFunctions(module2, implementation);
  }
  const synchronizer = synchronizer_default.create({ module: module2 });
  const defaultExportType = synchronizer.getInformation("default").type;
  if (defaultExportType === VALUE_TYPE_FUNCTION) {
    return synchronizer.createDefaultExportFunctionProxy();
  }
  return synchronizer.createModule();
}
var index_default = makeSynchronized;
export {
  index_default as default,
  makeDefaultExportSynchronized,
  makeModuleSynchronized,
  makeSynchronized,
  makeSynchronizedFunction,
  makeSynchronizedFunctions
};
